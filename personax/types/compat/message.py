from __future__ import annotations

import typing as t

import pydantic as pydt

from personax.types import BaseSchema
from personax.types.message import Messages as RawMessages


class Message(BaseSchema):
    """Completion-compatible message format.

    Simplified message structure for CompletionSystem input/output.
    Unlike the base Message type, this format requires string content
    (no image support) and is designed for direct LLM API consumption.

    Attributes:
        role: Message role ("user", "assistant", or "system").
        content: Text content of the message.

    Example:
        ```python
        # System message
        sys_msg = Message(
            role="system", content="You are a helpful assistant."
        )

        # User message
        user_msg = Message(role="user", content="What is 2+2?")

        # Assistant message
        asst_msg = Message(
            role="assistant", content="2+2 equals 4."
        )
        ```
    """

    role: t.Literal["user", "assistant", "system"]
    content: str

    __slots__ = ("content", "role")

    def __init__(
        self,
        *,
        role: t.Literal["user", "assistant", "system"],
        content: str,
    ) -> None:
        super().__init__()
        self.role = role
        self.content = content


class Messages(RawMessages):
    """Completion-compatible message collection with system prompt support.

    Extended message collection that allows system messages as the first
    message and validates completion-specific constraints. Used as input
    to CompletionSystem.complete().

    The validation ensures:
    - First message must be system role (typically the enriched prompt)
    - Last message must be user role (the query to complete)
    - Messages alternate between user and assistant (except first system
      message)

    Attributes:
        messages: Iterable of Message objects with system prompt support.

    Example:
        ```python
        # Valid completion messages
        messages = Messages(
            messages=[
                Message(
                    role="system",
                    content="You are a helpful assistant.",
                ),
                Message(role="user", content="Hello"),
                Message(
                    role="assistant", content="Hi! How can I help?"
                ),
                Message(role="user", content="What's the weather?"),
            ]
        )


        # Created from ContextCompose
        raw_messages = Messages(
            messages=[
                Message(role="user", content="What's the weather?"),
            ]
        )
        system_prompt = (
            "You are a helpful assistant. Current time: 2025-11-07"
        )

        compat_messages = Messages.from_raws(
            raw_messages, system_prompt
        )
        # Results in:
        # [
        #   Message(role="system", content="You are..."),
        #   Message(role="user", content="What's the weather?"),
        # ]
        ```
    """

    messages: t.Iterable[Message]  # type: ignore[assignment]

    @pydt.model_validator(mode="after")
    def validate_messages(self) -> t.Self:
        """Validate message structure for completion.

        Ensures:
        - First message is system role
        - Last message is user role
        - Messages alternate between user and assistant (system allowed first)

        Returns:
            Self after validation.

        Raises:
            ValueError: If validation fails.
        """
        self._validate(allow_system=True, first_role="system", last_role="user")
        return self

    @classmethod
    def from_raws(cls, raws: RawMessages, sys_prompt: str) -> t.Self:
        """Construct completion messages from raw messages and system prompt.

        Combines a system prompt (typically generated by ContextCompose) with
        the original conversation messages to create the final input for
        CompletionSystem.

        This is the standard way to convert context-built messages into the
        format expected by completion systems.

        Args:
            raws: Original conversation messages (user/assistant only).
            sys_prompt: System prompt containing enriched context from
                ContextCompose.

        Returns:
            Messages object with system prompt prepended.

        Example:
            ```python
            # After ContextCompose.build()
            context_messages = Messages(
                messages=[
                    Message(role="user", content="What should I wear?")
                ]
            )

            system_prompt = '''
            User Profile: John, Location: San Francisco
            Current Weather: 15Â°C, Cloudy
            Please respond based on the above context.
            '''

            # Convert to completion format
            completion_input = Messages.from_raws(
                context_messages, system_prompt
            )

            # Pass to completion system
            response = await completion_system.complete(
                completion_input, model="gpt-4"
            )
            ```
        """
        return cls.model_construct(
            messages=[
                Message(role="system", content=sys_prompt),
                *[Message(role=msg.role, content=msg.content or "") for msg in raws.messages],
            ]
        )
